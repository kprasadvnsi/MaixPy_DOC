{"./":{"url":"./","title":"Introduction","keywords":"","body":"MaixPy Documentation What is MaixPy MaixPy is a Micropython port on 64Bit Dual-Core RISC-V CPU K210, MicroPython is a lean and efficient implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimised to run on microcontrollers and in constrained environments. K210 created for AIOT(AI+IOT) use, It's powerful performance and low cost are very competitive. Micropython make program on hardware(K210) easier, so we build this and open source on github) For example if we want to find I2C device, we just need code: from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) If we want to make a breathing light by PWM, we just need code: from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty Take picture： import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img=sensor.snapshot() lcd.display(img) About this documentation Everything related to Maixpy, mainly about How to get a hardware( board ) How to get start with MaixPy even we are not so be expert in program for hardware. Learn Micropython basic knowledge Libriaries(API) reference Let's get started To get started, we need one dev board, there's three kind of board as follow: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go To get these board, visit Sipeed official website More hardware infomation here Then we can write software, refer to get started Source code MaixPy source code on github Maintained by ©Sipeed Co.,Ltd. More contributor here Source code of MaixPy documentation Doumentation will be edit if code api changed, source of doc on github You MUST read convention before edit doc! branch page build status master dev Feedback Doc feedback Code feedback "},"hardware/k210.html":{"url":"hardware/k210.html","title":"K210","keywords":"","body":"K210 "},"hardware/module.html":{"url":"hardware/module.html","title":"Module","keywords":"","body":"Modules Sipeed M1 (Lichee Dan) "},"hardware/m1.html":{"url":"hardware/m1.html","title":"Sipeed M1","keywords":"","body":"Sipeed M1 (Lichee Dan) "},"hardware/board.html":{"url":"hardware/board.html","title":"Board","keywords":"","body":"Board there's three kind of board as follow: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go "},"hardware/dan_dock.html":{"url":"hardware/dan_dock.html","title":"Dan Dock","keywords":"","body":"Sipeed M1 (Lichee Dan) Dan dock with Sipeed M1(Dan) module "},"hardware/bit.html":{"url":"hardware/bit.html","title":"BiT","keywords":"","body":"Sipeed Maix BiT "},"hardware/go.html":{"url":"hardware/go.html","title":"Go","keywords":"","body":"Sipeed Maix Go "},"hardware/peripheral_modules.html":{"url":"hardware/peripheral_modules.html","title":"Peripheral Modules","keywords":"","body":"Peripheral Modules Microphone array Binocular camera "},"get_started/prepare.html":{"url":"get_started/prepare.html","title":"Prepare","keywords":"","body":""},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"Get Hardware","keywords":"","body":""},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"Upgrade Firmware","keywords":"","body":""},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"Power On","keywords":"","body":""},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"LED Blink","keywords":"","body":""},"get_started/upload_script.html":{"url":"get_started/upload_script.html","title":"Upload Script To Dev Board","keywords":"","body":""},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"How To Read Docs","keywords":"","body":""},"mpy_basic_syntax/":{"url":"mpy_basic_syntax/","title":"Basic Syntax","keywords":"","body":"Micropython basic syntax "},"libs/":{"url":"libs/","title":"Libraries","keywords":"","body":"Libraries standard machine "},"libs/standard/":{"url":"libs/standard/","title":"standard","keywords":"","body":"standard libs cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect ustruct utime uzlib "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – mathematical functions for complex numbers This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: cmath. The cmath module provides some basic mathematical functions for working with complex numbers. Availability: not available on WiPy and ESP8266. Floating point support required for this module. Functions cos cmath.cos(z) Return the cosine of z. exp cmath.exp(z) Return the exponential of z. log cmath.log(z) Return the natural logarithm of z. The branch cut is along the negative real axis. log10 cmath.log10(z) Return the base-10 logarithm of z. The branch cut is along the negative real axis. phase cmath.phase(z) Returns the phase of the number z, in the range (-pi, +pi]. polar cmath.polar(z) Returns, as a tuple, the polar form of z. rect cmath.rect(r, phi) Returns the complex number with modulus r and phase phi. sin cmath.sin(z) Return the sine of z. sqrt cmath.sqrt(z) Return the square-root of z. Constants cmath.e base of the natural logarithm cmath.pi the ratio of a circle’s circumference to its diameter "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – control the garbage collector This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: gc. Functions gc.enable() Enable automatic garbage collection. gc.disable() Disable automatic garbage collection. Heap memory can still be allocated, and garbage collection can still be initiated manually using gc.collect(). gc.collect() Run a garbage collection. gc.mem_alloc() Return the number of bytes of heap RAM that are allocated. Difference to CPython This function is MicroPython extension. gc.mem_free() Return the number of bytes of available heap RAM, or -1 if this amount is not known. Difference to CPython This function is MicroPython extension. gc.threshold([amount]) Set or query the additional GC allocation threshold. Normally, a collection is triggered only when a new allocation cannot be satisfied, i.e. on an out-of-memory (OOM) condition. If this function is called, in addition to OOM, a collection will be triggered each time after amount bytes have been allocated (in total, since the previous time such an amount of bytes have been allocated). amount is usually specified as less than the full heap size, with the intention to trigger a collection earlier than when the heap becomes exhausted, and in the hope that an early collection will prevent excessive memory fragmentation. This is a heuristic measure, the effect of which will vary from application to application, as well as the optimal value of the amount parameter. Calling the function without argument will return the current value of the threshold. A value of -1 means a disabled allocation threshold. Difference to CPython This function is a MicroPython extension. CPython has a similar function - set_threshold(), but due to different GC implementations, its signature and semantics are different. "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – mathematical functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: math. The math module provides some basic mathematical functions for working with floating-point numbers. Note: On the pyboard, floating-point numbers have 32-bit precision. Availability: not available on WiPy. Floating point support required for this module. Functions math.acos(x) Return the inverse cosine of x. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asin(x) Return the inverse sine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atan(x) Return the inverse tangent of x. math.atan2(y, x) Return the principal value of the inverse tangent of y/x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.ceil(x) Return an integer, being x rounded towards positive infinity. math.copysign(x, y) Return x with the sign of y. math.cos(x) Return the cosine of x. math.cosh(x) Return the hyperbolic cosine of x. math.degrees(x) Return radians x converted to degrees. math.erf(x) Return the error function of x. math.erfc(x) Return the complementary error function of x. math.exp(x) Return the exponential of x. math.expm1(x) Return exp(x) - 1. math.fabs(x) Return the absolute value of x. math.floor(x) Return an integer, being x rounded towards negative infinity. math.fmod(x, y) Return the remainder of x/y. math.frexp(x) Decomposes a floating-point number into its mantissa and exponent. The returned value is the tuple (m, e) such that x == m * 2**e exactly. If x == 0 then the function returns (0.0, 0), otherwise the relation 0.5 holds. math.gamma(x) Return the gamma function of x. math.isfinite(x) Return True if x is finite. math.isinf(x) Return True if x is infinite. math.isnan(x) Return True if x is not-a-number math.ldexp(x, exp) Return x * (2**exp). math.lgamma(x) Return the natural logarithm of the gamma function of x. math.log(x) Return the natural logarithm of x. math.log10(x) Return the base-10 logarithm of x. math.log2(x) Return the base-2 logarithm of x. math.modf(x) Return a tuple of two floats, being the fractional and integral parts of x. Both return values have the same sign as x. math.pow(x, y) Returns x to the power of y. math.radians(x) Return degrees x converted to radians. math.sin(x) Return the sine of x. math.sinh(x) Return the hyperbolic sine of x. math.sqrt(x) Return the square root of x. math.tan(x) Return the tangent of x. math.tanh(x) Return the hyperbolic tangent of x. math.trunc(x) Return an integer, being x rounded towards 0. Constants math.e base of the natural logarithm math.pi the ratio of a circle’s circumference to its diameter "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":"sys – system specific functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: sys. Functions sys.exit(retval=0) Terminate current program with a given exit code. Underlyingly, this function raise as SystemExit exception. If an argument is given, its value given as an argument to SystemExit. sys.print_exception(exc, file=sys.stdout) Print exception with a traceback to a file-like object file (or sys.stdout by default). Difference to CPython This is simplified version of a function which appears in the traceback module in CPython. Unlike traceback.print_exception(), this function takes just exception value instead of exception type, exception value, and traceback object; file argument should be positional; further arguments are not supported. CPython-compatible traceback module can be found in micropython-lib. Constants sys.argv A mutable list of arguments the current program was started with. sys.byteorder The byte order of the system (\"little\" or \"big\"). sys.implementation Object with information about the current Python implementation. For MicroPython, it has following attributes: name - string “micropython” version - tuple (major, minor, micro), e.g. (1, 7, 0) This object is the recommended way to distinguish MicroPython from other Python implementations (note that it still may not exist in the very minimal ports). Difference to CPython CPython mandates more attributes for this object, but the actual useful bare minimum is implemented in MicroPython. sys.maxsize Maximum value which a native integer type can hold on the current platform, or maximum value representable by MicroPython integer type, if it’s smaller than platform max value (that is the case for MicroPython ports without long int support). This attribute is useful for detecting “bitness” of a platform (32-bit vs 64-bit, etc.). It’s recommended to not compare this attribute to some value directly, but instead count number of bits in it: bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules Dictionary of loaded modules. On some ports, it may not include builtin modules. sys.path A mutable list of directories to search for imported modules. sys.platform The platform that MicroPython is running on. For OS/RTOS ports, this is usually an identifier of the OS, e.g. \"linux\". For baremetal ports it is an identifier of a board, e.g. \"pyboard\" for the original MicroPython reference board. It thus can be used to distinguish one board from another. If you need to check whether your program runs on MicroPython (vs other Python implementation), use sys.implementation instead. sys.stderr Standard error stream. sys.stdin Standard input stream. sys.stdout Standard output stream. sys.version Python language version that this implementation conforms to, as a string. sys.version_info Python language version that this implementation conforms to, as a tuple of ints. "},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – binary/ASCII conversions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: binascii. This module implements conversions between binary data and various encodings of it in ASCII form (in both directions). Functions ubinascii.hexlify(data[, sep]) Convert binary data to hexadecimal representation. Returns bytes string. Difference to CPython If additional argument, sep is supplied, it is used as a separator between hexadecimal values. ubinascii.unhexlify(data) Convert hexadecimal data to binary representation. Returns bytes string. (i.e. inverse of hexlify) ubinascii.a2b_base64(data) Decode base64-encoded data, ignoring invalid characters in the input. Conforms to RFC 2045 s.6.8. Returns a bytes object. ubinascii.b2a_base64(data) Encode binary data in base64 format, as in RFC 3548. Returns the encoded data followed by a newline character, as a bytes object. "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – collection and container types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: collections. This module implements advanced collection and container types to hold/accumulate various objects. Classes ucollections.deque(iterable, maxlen[, flags]) Deques (double-ended queues) are a list-like container that support O(1) appends and pops from either side of the deque. New deques are created using the following arguments: iterable must be the empty tuple, and the new deque is created empty. maxlen must be specified and the deque will be bounded to this maximum length. Once the deque is full, any new items added will discard items from the opposite end. The optional flags can be 1 to check for overflow when adding items. As well as supporting bool and len, deque objects have the following methods: deque.append(x) Add x to the right side of the deque. Raises IndexError if overflow checking is enabled and there is no more room left. deque.popleft() Remove and return an item from the left side of the deque. Raises IndexError if no items are present. ucollections.namedtuple(name, fields) This is factory function to create a new namedtuple type with a specific name and set of fields. A namedtuple is a subclass of tuple which allows to access its fields not just by numeric index, but also with an attribute access syntax using symbolic field names. Fields is a sequence of strings specifying field names. For compatibility with CPython it can also be a a string with space-separated field named (but this is less efficient). Example of use: from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict type subclass which remembers and preserves the order of keys added. When ordered dict is iterated over, keys/items are returned in the order they were added: from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 "},"libs/standard/uctypes.html":{"url":"libs/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – access binary data in a structured way This module implements “foreign data interface” for MicroPython. The idea behind it is similar to CPython’s ctypes modules, but the actual API is different, streamlined and optimized for small size. The basic idea of the module is to define data structure layout with about the same power as the C language allows, and then access it using familiar dot-syntax to reference sub-fields. Warning uctypes module allows access to arbitrary memory addresses of the machine (including I/O and control registers). Uncareful usage of it may lead to crashes, data loss, and even hardware malfunction. See also Module ustruct Standard Python way to access binary data structures (doesn’t scale well to large and complex structures). Usage examples: import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 Defining structure layout Structure layout is defined by a “descriptor” - a Python dictionary which encodes field names as keys and other properties required to access them as associated values: { \"field1\": , \"field2\": , ... } Currently, uctypes requires explicit specification of offsets for each field. Offset are given in bytes from the structure start. Following are encoding examples for various field types: Scalar types: \"field_name\": offset | uctypes.UINT32 in other words, the value is a scalar type identifier ORed with a field offset (in bytes) from the start of the structure. Recursive structures: \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) i.e. value is a 2-tuple, first element of which is an offset, and second is a structure descriptor dictionary (note: offsets in recursive descriptors are relative to the structure it defines). Of course, recursive structures can be specified not just by a literal dictionary, but by referring to a structure descriptor dictionary (defined earlier) by name. Arrays of primitive types: \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with offset, and second is scalar element type ORed number of elements in the array. Arrays of aggregate types: \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with offset, second is a number of elements in the array, and third is a descriptor of element type. Pointer to a primitive type: \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, and second is a scalar element type. Pointer to an aggregate type: \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, second is a descriptor of type pointed to. Bitfields: \"bitf0\": offset | uctypes.BFUINT16 | lsbit i.e. value is a type of scalar value containing given bitfield (typenames are similar to scalar types, but prefixes with BF), ORed with offset for scalar value containing the bitfield, and further ORed with values for bit position and bit length of the bitfield within the scalar value, shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is counted from the least significant bit of the scalar (having position of 0), and is the number of right-most bit of a field (in other words, it’s a number of bits a scalar needs to be shifted right to extract the bitfield). In the example above, first a UINT16 value will be extracted at offset 0 (this detail may be important when accessing hardware registers, where particular access size and alignment are required), and then bitfield whose rightmost bit is lsbit bit of this UINT16, and length is bitsize bits, will be extracted. For example, if lsbit is 0 and bitsize is 8, then effectively it will access least-significant byte of UINT16. Note that bitfield operations are independent of target byte endianness, in particular, example above will access least-significant byte of UINT16 in both little- and big-endian structures. But it depends on the least significant bit being numbered 0. Some targets may use different numbering in their native ABI, but uctypes always uses the normalized numbering described above. Module contents class uctypes.struct(addr, descriptor, layout_type=NATIVE) Instantiate a “foreign data structure” object based on structure address in memory, descriptor (encoded as a dictionary), and layout type (see below). uctypes.LITTLE_ENDIAN Layout type for a little-endian packed structure. (Packed means that every field occupies exactly as many bytes as defined in the descriptor, i.e. the alignment is 1). uctypes.BIG_ENDIAN Layout type for a big-endian packed structure. uctypes.NATIVE Layout type for a native structure - with data endianness and alignment conforming to the ABI of the system on which MicroPython runs. uctypes.sizeof(struct, layout_type=NATIVE) Return size of data structure in bytes. The struct argument can be either a structure class or a specific instantiated structure object (or its aggregate field). uctypes.addressof(obj) Return address of an object. Argument should be bytes, bytearray or other object supporting buffer protocol (and address of this buffer is what actually returned). uctypes.bytes_at(addr, size) Capture memory at the given address and size as bytes object. As bytes object is immutable, memory is actually duplicated and copied into bytes object, so if memory contents change later, created object retains original value. uctypes.bytearray_at(addr, size) Capture memory at the given address and size as bytearray object. Unlike bytes_at() function above, memory is captured by reference, so it can be both written too, and you will access current value at the given memory address. uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 Integer types for structure descriptors. Constants for 8, 16, 32, and 64 bit types are provided, both signed and unsigned. uctypes.FLOAT32 uctypes.FLOAT64 Floating-point types for structure descriptors. uctypes.VOID VOID is an alias for UINT8, and is provided to conviniently define C’s void pointers: (uctypes.PTR, uctypes.VOID). uctypes.PTR uctypes.ARRAY Type constants for pointers and arrays. Note that there is no explicit constant for structures, it’s implicit: an aggregate type without PTR or ARRAY flags is a structure. Structure descriptors and instantiating structure objects Given a structure descriptor dictionary and its layout type, you can instantiate a specific structure instance at a given memory address using uctypes.struct() constructor. Memory address usually comes from following sources: Predefined address, when accessing hardware registers on a baremetal system. Lookup these addresses in datasheet for a particular MCU/SoC. As a return value from a call to some FFI (Foreign Function Interface) function. From uctypes.addressof(), when you want to pass arguments to an FFI function, or alternatively, to access some data for I/O (for example, data read from a file or network socket). Structure objects Structure objects allow accessing individual fields using standard dot notation: my_struct.substruct1.field1. If a field is of scalar type, getting it will produce a primitive value (Python integer or float) corresponding to the value contained in a field. A scalar field can also be assigned to. If a field is an array, its individual elements can be accessed with the standard subscript operator [] - both read and assigned to. If a field is a pointer, it can be dereferenced using [0] syntax (corresponding to C * operator, though [0] works in C too). Subscripting a pointer with other integer values but 0 are also supported, with the same semantics as in C. Summing up, accessing structure fields generally follows the C syntax, except for pointer dereference, when you need to use [0] operator instead of *. Limitations Accessing non-scalar fields leads to allocation of intermediate objects to represent them. This means that special care should be taken to layout a structure which needs to be accessed when memory allocation is disabled (e.g. from an interrupt). The recommendations are: Avoid accessing nested structures. For example, instead of mcu_registers.peripheral_a.register1, define separate layout descriptors for each peripheral, to be accessed as peripheral_a.register1. Or just cache a particular peripheral: peripheral_a = mcu_registers.peripheral_a. If a register consists of multiple bitfields, you would need to cache references to a particular register: reg_a = mcu_registers.peripheral_a.reg_a. Avoid other non-scalar data, like arrays. For example, instead of peripheral_a.register[0] use peripheral_a.register0. Again, an alternative is to cache intermediate values, e.g. register0 = peripheral_a.register[0]. Range of offsets supported by the uctypes module is limited. The exact range supported is considered an implementation detail, and the general suggestion is to split structure definitions to cover from a few kilobytes to a few dozen of kilobytes maximum. In most cases, this is a natural situation anyway, e.g. it doesn’t make sense to define all registers of an MCU (spread over 32-bit address space) in one structure, but rather a peripheral block by peripheral block. In some extreme cases, you may need to split a structure in several parts artificially (e.g. if accessing native data structure with multi-megabyte array in the middle, though that would be a very synthetic case).) "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — system error codes This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: errno. This module provides access to symbolic error codes for OSError exception. A particular inventory of codes depends on MicroPython port， Will explain the specific function that will cause an error. Constants EEXIST, EAGAIN, etc. Error codes, based on ANSI C/POSIX standard. All error codes start with “E”. As mentioned above, inventory of the codes depends on MicroPython port. Errors are usually accessible as exc.args[0] where exc is an instance of OSError. Usage example: try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode Dictionary mapping numeric error codes to strings with symbolic error code (see above): >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – heap queue algorithm This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: heapq. This module implements the heap queue algorithm. A heap queue is simply a list that has its elements stored in a certain way. Functions heappush uheapq.heappush(heap, item) Push the item onto the heap. heappop uheapq.heappop(heap) Pop the first item from the heap, and return it. Raises IndexError if heap is empty. heapify uheapq.heapify(x) Convert the list x into a heap. This is an in-place operation. "},"libs/standard/ujson.html":{"url":"libs/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: json. This modules allows to convert between Python objects and the JSON data format. Functions dump ujson.dump(obj, stream) Serialise obj to a JSON string, writing it to the given stream. dumps ujson.dumps(obj) Return obj represented as a JSON string. load ujson.load(stream) Parse the given stream, interpreting it as a JSON string and deserialising the data to a Python object. The resulting object is returned. Parsing continues until end-of-file is encountered. A ValueError is raised if the data in stream is not correctly formed. loads ujson.loads(str) Parse the JSON str and return an object. Raises ValueError if the string is not correctly formed. "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"uos – basic “operating system” services This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: os. The uos module contains functions for filesystem access and mounting, terminal redirection and duplication, and the uname and urandom functions. General functions uos.uname() Return a tuple (possibly a named tuple) containing information about the underlying machine and/or its operating system. The tuple has five fields in the following order, each of them being a string: sysname – the name of the underlying system nodename – the network name (can be the same as sysname) release – the version of the underlying system version – the MicroPython version and build date machine – an identifier for the underlying hardware (eg board, CPU) uos.urandom(n) Return a bytes object with n random bytes. Whenever possible, it is generated by the hardware random number generator. Filesystem access uos.chdir(path) Change current directory. uos.getcwd() Get the current directory. uos.ilistdir([dir]) This function returns an iterator which then yields tuples corresponding to the entries in the directory that it is listing. With no argument it lists the current directory, otherwise it lists the directory given by dir. The tuples have the form (name, type, inode[, size]): name is a string (or bytes if dir is a bytes object) and is the name of the entry; type is an integer that specifies the type of the entry, with 0x4000 for directories and 0x8000 for regular files; inode is an integer corresponding to the inode of the file, and may be 0 for filesystems that don’t have such a notion. Some platforms may return a 4-tuple that includes the entry’s size. For file entries, size is an integer representing the size of the file or -1 if unknown. Its meaning is currently undefined for directory entries. uos.listdir([dir]) With no argument, list the current directory. Otherwise list the given directory. uos.mkdir(path) Create a new directory. uos.remove(path) Remove a file. uos.rmdir(path) Remove a directory. uos.rename(old_path, new_path) Rename a file. uos.stat(path) Get the status of a file or directory. uos.statvfs(path) Get the status of a fileystem. Returns a tuple with the filesystem information in the following order: f_bsize – file system block size f_frsize – fragment size f_blocks – size of fs in f_frsize units f_bfree – number of free blocks f_bavail – number of free blocks for unpriviliged users f_files – number of inodes f_ffree – number of free inodes f_favail – number of free inodes for unpriviliged users f_flag – mount flags f_namemax – maximum filename length Parameters related to inodes: f_files, f_ffree, f_avail and the f_flags parameter may return 0 as they can be unavailable in a port-specific implementation. uos.sync() Sync all filesystems. Terminal redirection and duplication uos.dupterm(stream_object, index=0) Duplicate or switch the MicroPython terminal (the REPL) on the given stream-like object. The stream_object argument must implement the readinto() and write() methods. The stream should be in non-blocking mode and readinto() should return None if there is no data available for reading. After calling this function all terminal output is repeated on this stream, and any input that is available on the stream is passed on to the terminal input. The index parameter should be a non-negative integer and specifies which duplication slot is set. A given port may implement more than one slot (slot 0 will always be available) and in that case terminal input and output is duplicated on all the slots that are set. If None is passed as the stream_object then duplication is cancelled on the slot given by index. The function returns the previous stream-like object in the given slot. Filesystem mounting Some ports provide a Virtual Filesystem (VFS) and the ability to mount multiple “real” filesystems within this VFS. Filesystem objects can be mounted at either the root of the VFS, or at a subdirectory that lives in the root. This allows dynamic and flexible configuration of the filesystem that is seen by Python programs. Ports that have this functionality provide the mount() and umount() functions, and possibly various filesystem implementations represented by VFS classes. uos.mount(fsobj, mount_point, *, readonly) Mount the filesystem object fsobj at the location in the VFS given by the mount_point string. fsobj can be a a VFS object that has a mount() method, or a block device. If it’s a block device then the filesystem type is automatically detected (an exception is raised if no filesystem was recognised). mount_point may be '/' to mount fsobj at the root, or '/' to mount it at a subdirectory under the root. If readonly is True then the filesystem is mounted read-only. During the mount process the method mount() is called on the filesystem object. Will raise OSError(EPERM) if mount_point is already mounted. uos.umount(mount_point) Unmount a filesystem. mount_point can be a string naming the mount location, or a previously-mounted filesystem object. During the unmount process the method umount() is called on the filesystem object. Will raise OSError(EINVAL) if mount_point is not found. class uos.VfsFat(block_dev) Create a filesystem object that uses the FAT filesystem format. Storage of the FAT filesystem is provided by block_dev. Objects created by this constructor can be mounted using mount(). static mkfs(block_dev) Build a FAT filesystem on block_dev. Block devices A block device is an object which implements the block protocol, which is a set of methods described below by the AbstractBlockDev class. A concrete implementation of this class will usually allow access to the memory-like functionality a piece of hardware (like flash memory). A block device can be used by a particular filesystem driver to store the data for its filesystem. class uos.AbstractBlockDev(...) Construct a block device object. The parameters to the constructor are dependent on the specific block device. readblocks(block_num, buf) Starting at the block given by the index block_num, read blocks from the device into buf (an array of bytes). The number of blocks to read is given by the length of buf, which will be a multiple of the block size. writeblocks(block_num, buf) Starting at the block given by the index block_num, write blocks from buf (an array of bytes) to the device. The number of blocks to write is given by the length of buf, which will be a multiple of the block size. ioctl(op, arg) Control the block device and query its parameters. The operation to perform is given by op which is one of the following integers: 1 – initialise the device (arg is unused) 2 – shutdown the device (arg is unused) 3 – sync the device (arg is unused) 4 – get a count of the number of blocks, should return an integer (arg is unused) 5 – get the number of bytes in a block, should return an integer, or None in which case the default value of 512 is used (arg is unused) By way of example, the following class will implement a block device that stores its data in RAM using a bytearray: class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size It can be used as follows: import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":"ure – simple regular expressions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: re. This module implements regular expression operations. Regular expression syntax supported is a subset of CPython re module (and actually is a subset of POSIX extended regular expressions). Supported operators and special sequences . : Match any character. [...] : Match set of characters. Individual characters and ranges are supported, including negated sets (e.g. [^a-c]). ^ : Match the start of the string. $ : Match the end of the string. ? : Match zero or one of the previous sub-pattern. * : Match zero or more of the previous sub-pattern. + : Match one or more of the previous sub-pattern. ?? : Non-greedy version of ?, match zero or one, with the preference for zero. *? : Non-greedy version of *, match zero or more, with the preference for the shortest match. +? : Non-greedy version of +, match one or more, with the preference for the shortest match. | : Match either the left-hand side or the right-hand side sub-patterns of this operator. (...) : Grouping. Each group is capturing (a substring it captures can be accessed with match.group() method). \\d : Matches digit. Equivalent to [0-9]. \\D : Matches non-digit. Equivalent to [^0-9]. \\s : Matches whitespace. Equivalent to [ \\t-\\r]. \\S : Matches non-whitespace. Equivalent to [^ \\t-\\r]. \\w : Matches “word characters” (ASCII only). Equivalent to [A-Za-z0-9_]. \\W : Matches non “word characters” (ASCII only). Equivalent to [^A-Za-z0-9_]. \\ : Escape character. Any other character following the backslash, except for those listed above, is taken literally. For example, \\* is equivalent to literal * (not treated as the * operator). Note that \\r, \\n, etc. are not handled specially, and will be equivalent to literal letters r, n, etc. Due to this, it’s not recommended to use raw Python strings (r\"\") for regular expressions. For example, r\"\\r\\n\" when used as the regular expression is equivalent to \"rn\". To match CR character followed by LF, use \"\\r\\n\". NOT SUPPORTED: counted repetitions ({m,n}) named groups ((?P...)) non-capturing groups ((?:...)) more advanced assertions (\\b, \\B) special character escapes like \\r, \\n - use Python’s own escaping instead etc. Example: import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] Functions ure.compile(regex_str[, flags]) Compile regular expression, return regex object. ure.match(regex_str, string) Compile regex_str and match against string. Match always happens from starting position in a string. ure.search(regex_str, string) Compile regex_str and search it in a string. Unlike match, this will search string for first position which matches regex (which still may be 0 if regex is anchored). ure.sub(regex_str, replace, string, count=0, flags=0) Compile regex_str and search for it in string, replacing all matches with replace, and returning the new string. replace can be a string or a function. If it is a string then escape sequences of the form \\ and \\g can be used to expand to the corresponding group (or an empty string for unmatched groups). If replace is a function then it must take a single argument (the match) and should return a replacement string. If count is specified and non-zero then substitution will stop after this many substitutions are made. The flags argument is ignored. Note: availability of this function depends on MicroPython port. ure.DEBUG Flag value, display debug information about compiled expression. (Availability depends on MicroPython port.) Regex objects Compiled regular expression. Instances of this class are created using ure.compile(). regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) Similar to the module-level functions match(), search() and sub(). Using methods is (much) more efficient if the same regex is applied to multiple strings. regex.split(string, max_split=-1) Split a string using regex. If max_split is given, it specifies maximum number of splits to perform. Returns list of strings (there may be up to max_split+1 elements if it’s specified). Match objects Match objects as returned by match() and search() methods, and passed to the replacement function in sub(). match.group(index) Return matching (sub)string. index is 0 for entire match, 1 and above for each capturing group. Only numeric groups are supported. match.groups() Return a tuple containing all the substrings of the groups of the match. Note: availability of this method depends on MicroPython port. match.start([index]) match.end([index]) Return the index in the original string of the start or end of the substring group that was matched. index defaults to the entire group, otherwise it will select a group. Note: availability of these methods depends on MicroPython port. match.span([index]) Returns the 2-tuple (match.start(index), match.end(index)). Note: availability of this method depends on MicroPython port. "},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":""},"libs/standard/usocket.html":{"url":"libs/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – socket module This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: socket. This module provides access to the BSD socket interface. Difference to CPython For efficiency and consistency, socket objects in MicroPython implement a stream (file-like) interface directly. In CPython, you need to convert a socket to a file-like object using makefile() method. This method is still supported by MicroPython (but is a no-op), so where compatibility with CPython matters, be sure to use it. Socket address format(s) The native socket address format of the usocket module is an opaque data type returned by getaddrinfo function, which must be used to resolve textual address (including numeric addresses): sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) Using getaddrinfo is the most efficient (both in terms of memory and processing power) and portable way to work with addresses. However, socket module (note the difference with native MicroPython usocket module described here) provides CPython-compatible way to specify addresses using tuples, as described below. Note that depending on a MicroPython port, socket module can be builtin or need to be installed from micropython-lib (as in the case of MicroPython Unix port), and some ports still accept only numeric addresses in the tuple format, and require to use getaddrinfo function to resolve domain names. Summing up: Always use getaddrinfo when writing portable applications. Tuple addresses described below can be used as a shortcut for quick hacks and interactive use, if your port supports them. Tuple address format for socket module: IPv4: (ipv4_address, port), where ipv4_address is a string with dot-notation numeric IPv4 address, e.g. \"8.8.8.8\", and port is and integer port number in the range 1-65535. Note the domain names are not accepted as ipv4_address, they should be resolved first using usocket.getaddrinfo(). IPv6: (ipv6_address, port, flowinfo, scopeid), where ipv6_address is a string with colon-notation numeric IPv6 address, e.g. \"2001:db8::1\", and port is an integer port number in the range 1-65535. flowinfo must be 0. scopeid is the interface scope identifier for link-local addresses. Note the domain names are not accepted as ipv6_address, they should be resolved first using usocket.getaddrinfo(). Availability of IPv6 support depends on a MicroPython port. Functions usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) Create a new socket using the given address family, socket type and protocol number. Note that specifying proto in most cases is not required (and not recommended, as some MicroPython ports may omit IPPROTO_* constants). Instead, type argument will select needed protocol automatically: # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. Arguments af, type, and proto (which have the same meaning as for the socket() function) can be used to filter which kind of addresses are returned. If a parameter is not specified or zero, all combinations of addresses can be returned (requiring filtering on the user side). The resulting list of 5-tuples has the following structure: (family, type, proto, canonname, sockaddr) The following example shows how to connect to a given url: s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) Recommended use of filtering params: s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) Difference to CPython CPython raises a socket.gaierror exception (OSError subclass) in case of error in this function. MicroPython doesn’t have socket.gaierror and raises OSError directly. Note that error numbers of getaddrinfo() form a separate namespace and may not match error numbers from the uerrno module. To distinguish getaddrinfo() errors, they are represented by negative numbers, whereas standard system errors are positive numbers (error numbers are accessible using e.args[0] property from an exception object). The use of negative values is a provisional detail which may change in the future. usocket.inet_ntop(af, bin_addr) Convert a binary network address bin_addr of the given address family af to a textual representation: >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) Convert a textual network address txt_addr of the given address family af to a binary representation: >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' Constants usocket.AF_INET usocket.AF_INET6 Address family types. Availability depends on a particular MicroPython port. usocket.SOCK_STREAM usocket.SOCK_DGRAM Socket types. usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP protocol numbers. Availability depends on a particular MicroPython port. Note that you don’t need to specify these in a call to usocket.socket(), because SOCK_STREAM socket type automatically selects IPPROTO_TCP, and SOCK_DGRAM - IPPROTO_UDP. Thus, the only real use of these constants is as an argument to setsockopt(). usocket.SOL_* Socket option levels (an argument to setsockopt()). The exact inventory depends on a MicroPython port. usocket.SO_* Socket options (an argument to setsockopt()). The exact inventory depends on a MicroPython port. Constants specific to WiPy: usocket.IPPROTO_SEC Special protocol value to create SSL-compatible socket. class socket Methods socket.close() Mark the socket closed and release all resources. Once that happens, all future operations on the socket object will fail. The remote end will receive EOF indication if supported by protocol. Sockets are automatically closed when they are garbage-collected, but it is recommended to close() them explicitly as soon you finished working with them. socket.bind(address) Bind the socket to address. The socket must not already be bound. socket.listen([backlog]) Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it’s lower, it will be set to 0); and specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen. socket.accept() Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection. socket.connect(address) Connect to a remote socket at address. socket.send(bytes) Send data to the socket. The socket must be connected to a remote socket. Returns number of bytes sent, which may be smaller than the length of data (“short write”). socket.sendall(bytes) Send all data to the socket. The socket must be connected to a remote socket. Unlike send(), this method will try to send all of data, by sending data chunk by chunk consecutively. The behavior of this method on non-blocking sockets is undefined. Due to this, on MicroPython, it’s recommended to use write() method instead, which has the same “no short writes” policy for blocking sockets, and will return number of bytes sent on non-blocking sockets. socket.recv(bufsize) Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. socket.sendto(bytes, address) Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. socket.recvfrom(bufsize) Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data. socket.setsockopt(level, optname, value) Set the value of the given socket option. The needed symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a bytes-like object representing a buffer. socket.settimeout(value) Note: Not every port supports this method, see below. Set a timeout on blocking socket operations. The value argument can be a nonnegative floating point number expressing seconds, or None. If a non-zero value is given, subsequent socket operations will raise an OSError exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode. Not every MicroPython port supports this method. A more portable and generic solution is to use uselect.poll object. This allows to wait on multiple objects at the same time (and not just on sockets, but on generic stream objects which support polling). Example: # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out Difference to CPython CPython raises a socket.timeout exception in case of timeout, which is an OSError subclass. MicroPython raises an OSError directly instead. If you use except OSError: to catch the exception, your code will work both in MicroPython and CPython. socket.setblocking(flag) Set blocking or non-blocking mode of the socket: if flag is false, the socket is set to non-blocking, else to blocking mode. This method is a shorthand for certain settimeout() calls: sock.setblocking(True) is equivalent to sock.settimeout(None) sock.setblocking(False) is equivalent to sock.settimeout(0) socket.makefile(mode='rb', buffering=0) Return a file object associated with the socket. The exact returned type depends on the arguments given to makefile(). The support is limited to binary modes only (‘rb’, ‘wb’, and ‘rwb’). CPython’s arguments: encoding, errors and newline are not supported. Difference to CPython As MicroPython doesn’t support buffered streams, values of buffering parameter is ignored and treated as if it was 0 (unbuffered). Difference to CPython Closing the file object returned by makefile() WILL close the original socket as well. socket.read([size]) Read up to size bytes from the socket. Return a bytes object. If size is not given, it reads all data available from the socket until EOF; as such the method will not return until the socket is closed. This function tries to read as much data as requested (no “short reads”). This may be not possible with non-blocking socket though, and then less data will be returned. socket.readinto(buf[, nbytes]) Read bytes into the buf. If nbytes is specified then read at most that many bytes. Otherwise, read at most len(buf) bytes. Just as read(), this method follows “no short reads” policy. Return value: number of bytes read and stored into buf. socket.readline() Read a line, ending in a newline character. Return value: the line read. socket.write(buf) Write the buffer of bytes to the socket. This function will try to write all data to a socket (no “short writes”). This may be not possible with a non-blocking socket though, and returned value will be less than the length of buf. Return value: number of bytes written. exception usocket.error MicroPython does NOT have this exception. Difference to CPython CPython used to have a socket.error exception which is now deprecated, and is an alias of OSError. In MicroPython, use OSError directly. Demo Demo 1: Download picture and display on LCD attention set WiFi SSID and password first in code import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) Demo 2: Send picture import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() "},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – pack and unpack primitive data types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: struct. Supported size/byte order prefixes: @, , >, !. Supported format codes: b, B, h, H, i, I, l, L, q, Q, s, P, f, d (the latter 2 depending on the floating-point support). Functions calcsize ustruct.calcsize(fmt) Return the number of bytes needed to store the given fmt. pack ustruct.pack(fmt, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt. The return value is a bytes object encoding the values. pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt into a buffer starting at offset. offset may be negative to count from the end of buffer. unpack ustruct.unpack(fmt, data) Unpack from the data according to the format string fmt. The return value is a tuple of the unpacked values. unpack_from ustruct.unpack_from(fmt, data, offset=0) Unpack from the data starting at offset according to the format string fmt. offset may be negative to count from the end of buffer. The return value is a tuple of the unpacked values. "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – time related functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: time. The utime module provides functions for getting the current time and date, measuring time intervals, and for delays. Time Epoch: Unix port uses standard for POSIX systems epoch of 1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 00:00:00 UTC. Maintaining actual calendar date/time: This requires a Real Time Clock (RTC). On systems with underlying OS (including some RTOS), an RTC may be implicit. Setting and maintaining actual calendar time is responsibility of OS/RTOS and is done outside of MicroPython, it just uses OS API to query date/time. On baremetal ports however system time depends on machine.RTC() object. The current calendar time may be set using machine.RTC().datetime(tuple) function, and maintained by following means: By a backup battery (which may be an additional, optional component for a particular board). Using networked time protocol (requires setup by a port/user). Set manually by a user on each power-up (many boards then maintain RTC time across hard resets, though some may require setting it again in such case). If actual calendar time is not maintained with a system/MicroPython RTC, functions below which require reference to current absolute time may behave not as expected. Functions utime.localtime([secs]) Convert a time expressed in seconds since the Epoch (see above) into an 8-tuple which contains: (year, month, mday, hour, minute, second, weekday, yearday) If secs is not provided or None, then the current time from the RTC is used. year includes the century (for example 2014). month is 1-12 mday is 1-31 hour is 0-23 minute is 0-59 second is 0-59 weekday is 0-6 for Mon-Sun yearday is 1-366 utime.mktime() This is inverse function of localtime. It’s argument is a full 8-tuple which expresses a time as per localtime. It returns an integer which is the number of seconds since Jan 1, 2000. utime.sleep(seconds) Sleep for the given number of seconds. Some boards may accept seconds as a floating-point number to sleep for a fractional number of seconds. Note that other boards may not accept a floating-point argument, for compatibility with them use sleep_ms() and sleep_us() functions. utime.sleep_ms(ms) Delay for given number of milliseconds, should be positive or 0. utime.sleep_us(us) Delay for given number of microseconds, should be positive or 0. utime.ticks_ms() Returns an increasing millisecond counter with an arbitrary reference point, that wraps around after some value. The wrap-around value is not explicitly exposed, but we will refer to it as TICKS_MAX to simplify discussion. Period of the values is TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD is guaranteed to be a power of two, but otherwise may differ from port to port. The same period value is used for all of ticks_ms(), ticks_us(), ticks_cpu() functions (for simplicity). Thus, these functions will return a value in range [0 .. TICKS_MAX], inclusive, total TICKS_PERIOD values. Note that only non-negative values are used. For the most part, you should treat values returned by these functions as opaque. The only operations available for them are ticks_diff() and ticks_add() functions described below. Note: Performing standard mathematical operations (+, -) or relational operators (, >=) directly on these value will lead to invalid result. Performing mathematical operations and then passing their results as arguments to ticks_diff() or ticks_add() will also lead to invalid results from the latter functions. utime.ticks_us() Just like ticks_ms() above, but in microseconds. utime.ticks_cpu() Similar to ticks_ms() and ticks_us(), but with the highest possible resolution in the system. This is usually CPU clocks, and that’s why the function is named that way. But it doesn’t have to be a CPU clock, some other timing source available in a system (e.g. high-resolution timer) can be used instead. The exact timing unit (resolution) of this function is not specified on utime module level, but documentation for a specific port may provide more specific information. This function is intended for very fine benchmarking or very tight real-time loops. Avoid using it in portable code. Availability: Not every port implements this function. utime.ticks_add(ticks, delta) Offset ticks value by a given number, which can be either positive or negative. Given a ticks value, this function allows to calculate ticks value delta ticks before or after it, following modular-arithmetic definition of tick values (see ticks_ms() above). ticks parameter must be a direct result of call to ticks_ms(), ticks_us(), or ticks_cpu() functions (or from previous call to ticks_add()). However, delta can be an arbitrary integer number or numeric expression. ticks_add() is useful for calculating deadlines for events/tasks. (Note: you must use ticks_diff() function to work with deadlines.) Examples: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) Measure ticks difference between values returned from ticks_ms(), ticks_us(), or ticks_cpu() functions, as a signed value which may wrap around. The argument order is the same as for subtraction operator, ticks_diff(ticks1, ticks2) has the same meaning as ticks1 - ticks2. However, values returned by ticks_ms(), etc. functions may wrap around, so directly using subtraction on them will produce incorrect result. That is why ticks_diff() is needed, it implements modular (or more specifically, ring) arithmetics to produce correct result even for wrap-around values (as long as they not too distant inbetween, see below). The function returns signed value in the range [-TICKS_PERIOD/2 .. TICKS_PERIOD/2-1] (that’s a typical range definition for two’s-complement signed binary integers). If the result is negative, it means that ticks1 occurred earlier in time than ticks2. Otherwise, it means that ticks1 occurred after ticks2. This holds only if ticks1 and ticks2 are apart from each other for no more than TICKS_PERIOD/2-1 ticks. If that does not hold, incorrect result will be returned. Specifically, if two tick values are apart for TICKS_PERIOD/2-1 ticks, that value will be returned by the function. However, if TICKS_PERIOD/2 of real-time ticks has passed between them, the function will return -TICKS_PERIOD/2 instead, i.e. result value will wrap around to the negative range of possible values. Informal rationale of the constraints above: Suppose you are locked in a room with no means to monitor passing of time except a standard 12-notch clock. Then if you look at dial-plate now, and don’t look again for another 13 hours (e.g., if you fall for a long sleep), then once you finally look again, it may seem to you that only 1 hour has passed. To avoid this mistake, just look at the clock regularly. Your application should do the same. “Too long sleep” metaphor also maps directly to application behavior: don’t let your application run any single task for too long. Run tasks in steps, and do time-keeping inbetween. ticks_diff() is designed to accommodate various usage patterns, among them: Polling with timeout. In this case, the order of events is known, and you will deal only with positive results of ticks_diff(): # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError Scheduling events. In this case, ticks_diff() result may be negative if an event is overdue: # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) Note: Do not pass time() values to ticks_diff(), you should use normal mathematical operations on them. But note that time() may (and will) also overflow. This is known as https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained as described above. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (for embedded boards without a battery-backed RTC, usually since power up or reset). If you want to develop portable MicroPython application, you should not rely on this function to provide higher than second precision. If you need higher precision, use ticks_ms() and ticks_us()functions, if you need calendar time, localtime() without an argument is a better choice. Difference to CPython In CPython, this function returns number of seconds since Unix epoch, 1970-01-01 00:00 UTC, as a floating-point, usually having microsecond precision. With MicroPython, only Unix port uses the same Epoch, and if floating-point precision allows, returns sub-second precision. Embedded hardware usually doesn’t have floating-point precision to represent both long time ranges and subsecond precision, so they use integer value with second precision. Some embedded hardware also lacks battery-powered RTC, so returns number of seconds since last power-up or from other relative, hardware-specific point (e.g. reset). "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"zlib — zlib decompression This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: zlib. This module allows to decompress binary data compressed with DEFLATE algorithm (commonly used in zlib library and gzip archiver). Compression is not yet implemented. Functions decompress uzlib.decompress(data, wbits=0, bufsize=0) Return decompressed data as bytes. wbits is DEFLATE dictionary window size used during compression (8-15, the dictionary size is power of 2 of that value). Additionally, if value is positive, data is assumed to be zlib stream (with zlib header). Otherwise, if it’s negative, it’s assumed to be raw DEFLATE stream. bufsize parameter is for compatibility with CPython and is ignored. DecompIO class uzlib.DecompIO(stream, wbits=0) Create a stream wrapper which allows transparent decompression of compressed data in another stream. This allows to process compressed streams with data larger than available heap size. In addition to values described in decompress(), wbits may take values 24..31 (16 + 8..15), meaning that input stream has gzip header. Difference to CPython This class is MicroPython extension. It’s included on provisional basis and may be changed considerably or removed in later versions. "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":""},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer Hardware timers deal with timing of periods and events. Timers are perhaps the most flexible and heterogeneous kind of hardware in MCUs and SoCs, differently greatly from a model to a model. MicroPython’s Timer class defines a baseline operation of executing a callback with a given period (or once after some delay), and allow specific boards to define more non-standard behavior (which thus won’t be portable to other boards). Constructors class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) Construct a new timer object of the given id. Parameters id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer channel, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer mode, MODE_ONE_SHOT or MODE_PERIODICor MODE_PWM period: Timer period, after period the callback will be invoke, (0,~). unit: unit of timer, default ms, Timer.UNIT_S or Timer.UNIT_MS or Timer.UNIT_US orTimer.UNIT_NS callback: Timer callback, two parameters, first is Timer, second is user param, see param parameter below. callback execute in interrupt, so don't stay too long in callback arg: Argument dilivered to callback start: If start instantly timer after init, True:start, False:not start, need call start() function. priority: interrupt priority, [1,7]. div: Timer clock divider,[0,255],default to 0. clk_timer = clk_pll0/2^(div+1) clk_timer*period(unit:s) should =1 Methods init Same to constructor Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) callback Get or set callback e.g. def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim.callback(on_timer) print(on_timer, tim.callback()) period Get or set period e.g. tim.period(2000) print( tim.period() ) start Start timer e.g. tim.start() stop Stop timer restart Restart timer deinit/del Deinitialises the timer. Stops the timer, and disables the timer peripheral. e.g. tim.deinit() or del tim Constants TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer channel 0 CHANNEL1: Timer channel 1 CHANNEL2: Timer channel 2 CHANNEL3: Timer channel 3 MODE_ONE_SHOT: Timer only run once MODE_PERIODIC: Timer always run MODE_PWM: Timer used by PWM UNIT_S: unit flag (s) UNIT_MS: unit flag (ms) UNIT_US: unit flag (us) UNIT_NS: unit flag (ns) Demo Demo 1 Print data after 3s just once from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, param=on_timer) print(\"period:\",tim.period()) tim.start() Demo 2 Print every 1s, and stop 5s then restart 5s then shutdown import time from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, param=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART "},"contribute/":{"url":"contribute/","title":"Contribute","keywords":"","body":"Participate in the contribution Since it is an open source project, everyone is welcome to join in to improve MaixPy. Due to the large number of people, we need a common agreement (including format, style, etc.) There are mainly the following aspects that can be involved: document modification MaixPy firmware bug fix, feature optimization, feature addition, etc. "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"doc convention","keywords":"","body":"Document specification Documents are built using gitbook and written in simple and efficient Markdown The documentation source is hosted on github Markdown syntax If you never touched the basic syntax of Markdown, please take half an hour to learn, recommend the github tutorial: github Markdown tutorial In this article, we need to pay attention to the following points: The syntax tags of the title class must be separated by spaces. A blank line is required between the headline and the body, such as: ## This is a secondary title * This is list item 1 * This is list item 2 And the following is not correct, it may cause the parser to parse the error format, etc. ##This is a secondary title *This is list item 1 *This is list item 2 All pages have only one top level title Because the need to automatically generate a directory, mainly to ensure that the automatically generated directory is correct. Write each page like this Page title/top level title ======= (There is at least three equals here) (At least one more blank line is required, 2 lines are recommended) ## Secondary title 1 (You cannot use a first-level title here, and you cannot use a ##. You don't need to write a serial number, it will automatically generate a serial number.) ( Skip a line ) text (at least one line) ### Three-level title (similar to the second-level title, it does not need to be written, it will be generated automatically) text ## Secondary title 2 text Link Due to the large number of pages and the need to link resources such as images, relative paths are used when writing links. Such as the directory structure is as follows Assets/ (put public resource files) | ----pic000.png En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md Zh/ If you want to show the images in get_hardware.md, put the image into the assets folder, use the following code to reference the image. ![pic](assets/pic.png) ![pic](../../assets/pic000.png) Chinese and English mixed When writing Chinese documents, the Chinese characters should be separated by spaces as much as possible. Punctuation should use full-width symbols as much as possible. Mainly to make it stand out and make the document more elegant. For example, the following comparison: In Micropython, we often use `deinit` to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. Directory and file name The generated document directory is edited in the corresponding language folder SUMMARY.md The source document folder should be a function module corresponding to a folder, and the resource file (picture) is placed in the assets folder directory of the current path of the corresponding md document, which is more convenient when adding, deleting, and modifying. Assets/ (put public resource files) En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ---- get_hardware.md | ---- how_to_read.md Zh/ The file name is not limited to README.md, other file names are named with lowercase + underscore, such as get_hardware.md Catalog and links Try to guide readers to use the directory, and use the jump link in the text with caution. If the link jumps in a mess, it will cause the document to look messy and it will be difficult to read. Chinese and English (multi-language) page file directory structure and file name are the same Since there are multiple language switching options in the last generated page, clicking the switch will directly access the same path of the corresponding language, so the Chinese and English directory structure and file name must be the same. For example, English is accessing en/get_started/how_to_read.md. After clicking the button for language switching, it will automatically access zh/get_started/how_to_read.md. If this file does not exist, it will report a 404 error! Module Document Content Need to include a module introduction in the file header Need to explain the constructor, function, constant, etc. Explain that you can't be lazy. Simply translate the function name again. You need to explain the function of the function, the range of parameters, and the point of attention Multi-version management In addition to the Chinese and English (multi-language) support (not automatic translation, manual modification), the document also has multi-version management. Each version is a branch with requirements for the branch name, which are: master branch is the main branch dev branch for development branch Other published historical versions start with a lowercase v, such as creating a branch called v1.2 After creating a new branch, you need to modify the version link in book.json in the directory of each language version, otherwise the reader can't find the entry. You can preview it locally under the newly created branch (see the root directory README.md for the preview method). Note that the previewed page is the current branch. If you want to preview other branches locally, you need to switch to other points before previewing. Just fine. After confirming that the error is modified, push the branch to the remote (github), the automatic build system will be automatically built and published to the pages branch, and the effect will be seen when the access URL is built. "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"code convention","keywords":"","body":"Code Convention "},"contribute/compile.html":{"url":"contribute/compile.html","title":"code compile","keywords":"","body":"Code Compile Refer to the README in source code "},"others/open_projects.html":{"url":"others/open_projects.html","title":"Open Source Projects","keywords":"","body":"Open source projects related to MaixPy If you have open source project, pull request or tell us by issue or send email(support@sipeed.com)! We are happy to receive your feedback and your contribution! "}}